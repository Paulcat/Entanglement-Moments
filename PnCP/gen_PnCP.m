function [Maps,Deltas] = gen_PnCP(n,m,options,varargin)
%GEN_PNCP Generate PnCP map(s) following [Klep, 2017]
%   PHI = GEN_PNCP(N,M,OPTIONS,VARARGIN) returns a (collection of) PnCP
%   maps.
%
%   PHI is a (collection of) array of size (M*M x N*N). One can apply Phi
%   to a matrix A of size (N x N) by doing PHI * A(:), and reshaping.
%
%   Successive maps are generated by re-initializing random parameters
%   (seed points and vectors in kernels)
%
%   Supported options:
%    - mode: 
%       'hit-tol' (default): return one PnCP map satysfing criterion
%       'gen-many'         : return all maps found including bad ones
%    - ntest (100)         : maximum number of tries (re-initializations)
%    - tol (1e-2)          : tolerance for the hit-tol mode
%    - solver (mosek)      : solver for the SDP program
%    - toolbox (yalmip)    : yalmip or (todo: cvx)
%    - verbose (1)
%
%   See also GEN_ONE_PNCP

d = n+m-2;


% process input options % TODO: put in separate function?
mode    = getoptions(options,'mode','hit-tol');
nmax    = getoptions(options,'ntest',100);
maxor   = getoptions(options,'maxorder',2);
tol_de  = getoptions(options,'tol',1e-2);
method  = getoptions(options,'method','klep');
solver  = getoptions(options,'solver','mosek');
toolbox = getoptions(options,'toolbox','yalmip');
verbose = getoptions(options,'verbose',1);

tol_mode = strcmp(mode,'hit-tol'); % check for tolerance mode


Maps   = [];
Deltas = [];
i      = 0;
if verbose && tol_mode
	fprintf('%2s Generate random PnCP until one works (maximum number of tries: %i)\n','',nmax)
elseif verbose
	fprintf('%2s Generate random PnCP, no quality control (maximum: %I)\n','',nmax);
end
while i<=nmax
	%fprintf('%i ',i);
	%if ~mod(i+1,30)
	%	fprintf('\n');
	%end

	% random initial points and resulting kernels
	% [~,~,Z]     = Klep_step1_1(n,m,'example'); % specific points
	[~,~,Z]     = Klep_step1_1(n,m);
	[~,K,K1]    = Klep_step1_2(n,m,Z);
	[~,K_inter] = Klep_step2(n,m,Z);

	% dimensions
	dK = size(K,2);
	d1 = size(K1,2);
	di = size(K_inter,2);
	K  = reshape(K,[],1,dK);

	% d random linear combination in K
	al = rand(1,d,dK);
	vj = sum(al.*K,3); % % each column defines the linear form <vj',z>
	vj = reshape(vj,n,m,d); % row and columns are switched (cf Klep_step2.m)
	% (reshape is probably useless)

	% one in K1
	be = rand(1,d1);
	v0 = sum(be.*K1,2);
	v0 = reshape(v0,n,m); % rows and columns switched

	% all vectors
	vh = cat(3,v0,vj);

	% one in K_inter
	ga = rand(1,di);
	vf = sum(ga.*K_inter,2);
	vf = reshape(vf,[m,n,m,n]); % TODO: check if dimensions are in correct order!

	% compute PnCP map
	[phi,delta,info]  = gen_one_PnCP(n,m,vf,vh,...
		'verbose',verbose,'maxorder',maxor,'solver',solver,'toolbox',toolbox,...
		'method',method,'tolerance',tol_de);
	
	% store results
	Maps(:,:,end+1) = phi;
	Deltas(end+1)   = delta;

	if info.success && tol_mode
		Maps   = Maps(:,:,end);
		Deltas = Deltas(end);
		break;
	end
	
	i = i+1;
end
%fprintf('\n\n');

if i==nmax+1 && tol_mode
	% no satisfying map was found
	fprintf('\t no satisfying map was found, returning random map\n');
	Maps = rand(m^2,n^2);
elseif tol_mode
	fprintf('\t map found: residual=%d, delta=%d, sdpflag = %i\n',...
		info.res,delta,info.flag_sol)
end

end

